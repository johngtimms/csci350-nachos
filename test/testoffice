#include "syscall.h"

typedef int bool;
#define true 1
#define false 0

struct Customer;
struct Clerk;
struct Manager;

int numCustomers, numApplicationClerks;

int nextAvailableCustomerIndex = 0;
int nextAvailableApplicationClerkIndex = 0;

int customerIndexLock;
int applicationClerkIndexLock;

typedef enum {FREE, BUSY, BREAK} ClerkState;
typedef enum {APPLICATION_CLERK, PICTURE_CLERK, PASSPORT_CLERK, CASHIER} ClerkType;
int amounts[] = {100, 600, 1100, 1600}; /*random amounts of money customer can start with */

typedef struct Customer {
	
	int money;
	int clerkID;
	int SSN;
	bool didBribe;		
	bool isSenator;
	bool hasApp;
	bool hasPic;
	bool certifiedByPassportClerk;
	bool hasPassport;
	bool hasPaidForPassport;
	bool seenApp;
	bool seenPic;
	bool likedPic;

} Customer;

typedef struct Clerk {
	
	int lineLength;
	int bribeLineLength;
	int senatorLineLength;
	int money;

	ClerkState state;
	Customer customer;	

	int lineLock, bribeLineLock, senatorLineLock, clerkLock, moneyLock;
	int lineCV, bribeLineCV, senatorLineCV, clerkCV, breakCV;

} Clerk;

Customer customers[10];
Clerk applicationClerks[3];

void initCustomer(int i, bool _isSenator) {
	customers[i].isSenator = _isSenator;
    customers[i].clerkID = -1;
    customers[i].SSN = i;
    customers[i].money = amounts[(int)(Rand() % 4)];
    customers[i].hasApp = false;
    customers[i].hasPic = false;
    customers[i].certifiedByPassportClerk = false;
    customers[i].hasPassport = false;
    customers[i].seenApp = false;
    customers[i].seenPic = false;
    customers[i].likedPic = false;
    customers[i].hasPaidForPassport = false;
}

void initApplicationClerk(int i) {
	applicationClerks[i].lineLength = 0;
	applicationClerks[i].bribeLineLength = 0;
	applicationClerks[i].senatorLineLength = 0;
	applicationClerks[i].money = 0;
	applicationClerks[i].state = BUSY;
	applicationClerks[i].lineLock = CreateLock();
	applicationClerks[i].bribeLineLock = CreateLock();
	applicationClerks[i].senatorLineLock = CreateLock();
	applicationClerks[i].moneyLock = CreateLock();
	applicationClerks[i].lineCV = CreateCondition();
	applicationClerks[i].bribeLineCV = CreateCondition();
	applicationClerks[i].senatorLineCV = CreateCondition();
	applicationClerks[i].clerkCV = CreateCondition();
	applicationClerks[i].breakCV = CreateCondition();
}

void doApplication(int ssn) {
	/*
	this->waitInLine(applicationClerks, numApplicationClerks);
	Clerk* clerk = applicationClerks[clerkID];
	cout<<clerk->getName() << " has signalled " << this->getName() << " to come to their counter." << endl;
	clerk->customer = this;
    // Interaction with clerk
    clerk->clerkLock->Acquire();
    clerk->clerkCV->Signal(clerk->clerkLock); // Give incomplete application to Application Clerk
    printf("%s has given SSN %i to %s.\n", this->name, this->SSN,clerk->name);
    clerk->clerkCV->Wait(clerk->clerkLock);   // Wait for Application Clerk
    clerk->clerkCV->Signal(clerk->clerkLock); // Accept completed application
    hasApp = true;
    clerk->clerkLock->Release();
    */
}

void runCustomer() {
	int i;

	Acquire(customerIndexLock);
	customerIndexLock
	i = nextAvailableCustomerIndex;
	initCustomer(i, false); 
	Print("running customer %i\n",i);
	nextAvailableCustomerIndex = nextAvailableCustomerIndex + 1;
	Release(customerIndexLock);
	
    doApplication(customers[i].SSN);

	Exit(0);
}

void runApplicationClerk() {
	int i;
	Acquire(applicationClerkIndexLock);
	i = nextAvailableApplicationClerkIndex;
	Print("running applicationClerk: %i\n", i);
	initApplicationClerk(i);
	nextAvailableApplicationClerkIndex = nextAvailableApplicationClerkIndex + 1;
	Release(applicationClerkIndexLock);

	Exit(0);
}

int main() {
	int k;
	numCustomers = 10;
	numApplicationClerks = 1;

	customerIndexLock = CreateLock();
	applicationClerkIndexLock = CreateLock();

	for(k = 0; k < numApplicationClerks; k++) {
		Fork(&runApplicationClerk);
	}
	for(k = 0; k < numCustomers; k++) {
		Fork(&runCustomer);	
	}

	Destroy_Lock(customerIndexLock);
	Destroy_Lock(applicationClerkIndexLock);
	Exit(0);
}



/*
void chooseLine(Clerk** clerks, int numClerks){
	int minLength = 51;
	bool canBribe = false;

	if (money > 500) 
		canBribe = true;

	// Choose the shortest line possible
	for (int i = 0; i < numClerks; i++) {
		if (clerks[i]->lineLength < minLength) {
			clerkID = i;
			minLength = clerks[i]->lineLength;
			didBribe = false;
		}

		if (canBribe) {
			if (clerks[i]->bribeLineLength < minLength) {
				clerkID = i;
				minLength = clerks[i]->bribeLineLength;
				didBribe = true;
			}
		}
	}
}


bool enterLine(Clerk* clerk) {
	// Stand in line
	if (clerk->state != FREE) {
		if(isSenator) {
			clerk->senatorLineLock->Acquire();
			clerk->senatorLineLength++;
			printf("%s has gotten in senator line for %s.\n", currentThread->getName(), clerk->getName());
			clerk->senatorLineCV->Wait(clerk->senatorLineLock);
			clerk->senatorLineLength--;
		}
		else if (didBribe) {
			clerk->bribeLineLock->Acquire();
			clerk->bribeLineLength++;
			printf("%s has gotten in bribe line for %s.\n", currentThread->getName(), clerk->getName());
			clerk->bribeLineCV->Wait(clerk->bribeLineLock);
			clerk->bribeLineLength--;
		} else {
			clerk->lineLock->Acquire();
			clerk->lineLength++;
			printf("%s has gotten in regular line for %s.\n", currentThread->getName(), clerk->getName());
			clerk->lineCV->Wait(clerk->lineLock);
			clerk->lineLength--;
		}
	}

	// Called out of line, make sure it wasn't because of a senator
	senatorInsideLock->Acquire();
	if (senatorInside && !isSenator) {
		senatorInsideLock->Release();
		clerk->bribeLineLock->Release();
		clerk->lineLock->Release();
		customerOutsideLineLock->Acquire();
		printf("%s is going outside the Passport Office because there is a Senator present.\n", currentThread->getName());
		customersOutside += 1;
		customerOutsideLineCV->Wait(customerOutsideLineLock);
		customersOutside -= 1;
		customerOutsideLineLock->Release();
		return true;
	} else {
		senatorInsideLock->Release();

		// Change the clerk to BUSY before releasing the clerk's line lock
		clerk->state = BUSY;
		clerk->bribeLineLock->Release();
		clerk->lineLock->Release();
		clerk->senatorLineLock->Release();

		return false;
	}
}
*/
void waitInLine(int ssn, ClerkType clerkType) {
	/*
	bool senatord = false;
	this->chooseLine(clerks, numClerks);
	senatord = this->enterLine(clerks[clerkID]);
	while(senatord) {
		this->chooseLine(clerks, numClerks);
		senatord = this->enterLine(clerks[clerkID]);
	}
	if (didBribe) {
		money -= 500;
		clerks[clerkID]->moneyLock->Acquire();
		clerks[clerkID]->money += 500;
		clerks[clerkID]->moneyLock->Release();
	}

	

	*/
	bool senatord;
	senatord = false;
	clerkID = chooseLine(clerkType);
	senatord = enterLine(clerkType, clerkID);
	while(senatord) {
		clerkID = chooseLine(clerkType);
		senatord = enterLine(clerkType, clerkID);
	}
	if(customers[ssn].didBribe) {
		customers[ssn].money = customers[ssn] - 500;
		switch(clerkType) {
			case APPLICATION_CLERK:
				Acquire(applicationClerks[clerkID].moneyLock);
				applicationClerks[clerkID].money = applicationClerks[clerkID].money + 500;
				Release(applicationClerks[clerkID].moneyLock);
				break;
			case PICTURE_CLERK:
				Acquire(pictureClerks[clerkID].moneyLock);
				pictureClerks[clerkID].money = pictureClerks[clerkID].money + 500;
				Release(pictureClerks[clerkID].moneyLock);
				break;
			case PASSPORT_CLERK:
				Acquire(passportClerks[clerkID].moneyLock);
				passportClerks[clerkID].money = passportClerks[clerkID].money + 500;
				Release(passportClerks[clerkID].moneyLock);
				break;
			case CASHIER:
				Acquire(cashiers[clerkID].moneyLock);
				cashiers[clerkID].money = applicationClerks[clerkID].money + 500;
				Release(applicationClerks[clerkID].moneyLock);
				break;
		}
	}

	
}
